(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{395:function(e,o,t){"use strict";t.r(o);var n=t(44),a=Object(n.a)({},(function(){var e=this,o=e.$createElement,t=e._self._c||o;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"常见面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见面试题"}},[e._v("#")]),e._v(" 常见面试题")]),e._v(" "),t("p",[e._v("1、Cookie和Session有什么区别？如何使用Session进行身份验证")]),e._v(" "),t("blockquote",[t("p",[e._v("1、Session的主要作用就是通过服务端记录用户的状态；")]),e._v(" "),t("p",[e._v("2、Cookie数据保存在客户端（浏览器端），Session数据保存在服务器端。相对来说Session安全性更高。如果使用Cookie的话，一些敏感信息不要写入Cookie中，最好能将Cookie信息加密然后使用到的时候再去服务器端解密；")]),e._v(" "),t("p",[e._v("3、那么如何使用Session进行身份验证？")]),e._v(" "),t("p",[e._v("很多时候我们都是通过SessionId来指定特定的用户，SessionID一般会选择存放在服务器端。举个例子：用户成功登陆系统，然后返回客户端具有SessionId的cookie，当用户向后端发起请求的时候会把SessionId带上，这样后端就知道你的身份状态，关于这种认证方式更详细的过程如下：")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://img-blog.csdnimg.cn/20201017200419165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTAxMTIy,size_16,color_FFFFFF,t_70#pic_center",alt:"session"}})]),e._v(" "),t("p",[e._v("2、BeanFactory和ApplicationContext有什么区别：")]),e._v(" "),t("p",[e._v("相同：")]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("Spring提供了两种不同的IOC容器，一个是BeanFactory、另外一个是ApplicationContext，它们都是java interface，ApplicationContext继承于beanFactory（ApplicationContext继承ListableBeanFactory）；")]),e._v(" "),t("li",[e._v("它们都可以使用XML配置文件，也支持属性的自动注入；")]),e._v(" "),t("li",[e._v('而ListableBeanFactory继承BeanFactory，BeanFactory和ApplicationoContext都提供了一种方式，使用getBean("bean name")获取bean')])])]),e._v(" "),t("p",[e._v("不同：")]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("当你使用getBean()方法时，BeanFactory仅实例化bean，而ApplicationContext在启动容器的时候实例化单例bean，不会等待调用getBean()方法时实例化；")]),e._v(" "),t("li",[e._v("BeanFactory不支持国际化，即i18n，但ApplicationContext提供了对它的支持；")]),e._v(" "),t("li",[e._v("BeanFactory提供了基本的IOC和DI功能，而ApplicationContext是BeanFactory的子接口。是个高级容器，提供额外的功能：国际化、消息推送、响应机制、统一加载资源，事件机制；")])])]),e._v(" "),t("p",[e._v("3、分布锁有哪些解决方案？")]),e._v(" "),t("blockquote",[t("p",[e._v("1、Redis的分布式锁，很多大公司会基于Redis做扩展开发。setnx，Redisson")]),e._v(" "),t("p",[e._v("2、基于Zookeeper：顺序临时节点")]),e._v(" "),t("p",[e._v("3、基于数据库，比如mysql，主键或唯一索引的唯一性")])]),e._v(" "),t("p",[e._v("4、缓存雪崩、缓存穿透、缓存击穿在实际中如何处理？")]),e._v(" "),t("p",[e._v("三大问题：")]),e._v(" "),t("blockquote",[t("p",[e._v("1、缓存穿透：缓存不存在，数据库不存在，高并发，少量key")]),e._v(" "),t("p",[e._v("2、缓存击穿：缓存不存在，数据库存在，高并发，少量key")]),e._v(" "),t("p",[e._v("3、缓存雪崩：缓存不存在，数据库存在，高并发，大量key")])]),e._v(" "),t("p",[e._v("解决方案：")]),e._v(" "),t("blockquote",[t("p",[e._v("1、缓存穿透：如果一个查询返回的数据为空（不管数据存不存在还是系统出现故障），我们仍然把这个空结果进行缓存，但是它的过期时间会很短，最长不超过5分钟；")]),e._v(" "),t("p",[e._v("2、缓存击穿：使用互斥锁、“提前”使用互斥锁、永远不过期、资源保护")]),e._v(" "),t("p",[e._v("3、缓存雪崩：将缓存的失效时间分散开，比如我们可以在原有的失效时间的基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引起机体失效的事件；")])])])}),[],!1,null,null,null);o.default=a.exports}}]);